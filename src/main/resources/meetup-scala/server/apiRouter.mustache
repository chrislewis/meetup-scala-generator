package {{package}}
{{#operations}}
{{#imports}}import {{import}}
{{/imports}}

import io.netty.buffer.ByteBuf
import io.netty.handler.codec.http.HttpResponseStatus
import io.reactivex.netty.protocol.http.server.{HttpServerRequest, HttpServerResponse, RequestHandler}

import io.netty.handler.codec.http.{HttpHeaderNames, HttpResponseStatus}

import {{invokerPackage}}.{Router, Serializer, Codec, Service, Util}

import java.nio.charset.Charset

import rx.functions.Func1
import rx.{Observable => JObservable}

class {{classname}}Router(api: {{classname}}) extends Router(api) {
    def handleRequest(request: HttpServerRequest[ByteBuf], response: HttpServerResponse[ByteBuf]): rx.Observable[Void] = {
        val path = request.getPath.split("/").toList.drop(1)
        val method = request.getHttpMethod.name().toUpperCase()

        (path, method) match {
{{#operation}}
          case ({{{vendorExtensions.x-meetup-scala-op-case}}} :: Nil, "{{httpMethod}}") =>
            {{#bodyParams}}
            val body: rx.Observable[ByteBuf] = request
              .getContent

            val r: rx.Observable[Void] = body.flatMap {
              new Func1[ByteBuf, rx.Observable[Void]]() {
                override def call(byteBuf: ByteBuf): rx.Observable[Void] = {
                  val json = byteBuf.toString(Charset.defaultCharset())
                  val deserialized:Either[String, {{dataType}}] = Serializer.deserialize[{{dataType}}](json)
                  deserialized match {
                    case Right(content) =>
                      val result:{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}Unit{{/returnType}} = api.{{operationId}}({{#pathParams}}{{paramName}}.to{{dataType}},{{/pathParams}}content)
                      val r: JObservable[Void] = respond(result, response)
                      r
                    case Left(msg) =>
                      badRequest(response)
                  }
                }
              }
            }
            r
            {{/bodyParams}}

          {{#formParams}}
          Util.getFormParameters(request).flatMap {
            new Func1[Map[String, List[String]], rx.Observable[Void]]() {
              override def call(params: Map[String, List[String]]): rx.Observable[Void] = {
                val result: {{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}Unit{{/returnType}} =
                  api.{{operationId}}(
                    {{#pathParams}}{{paramName}}.to{{dataType}}{{#hasMore}}, {{/hasMore}}{{/pathParams}}
                    {{#hasPathParams}}, {{/hasPathParams}}{{^required}}Option({{/required}}params.getOrElse("{{paramName}}", null){{^required}}).map(_{{/required}}.apply(0).to{{dataType}}{{^required}}){{/required}}{{#hasMore}}, {{/hasMore}})
                val r: JObservable[Void] = respond(result, response)
                r
              }
            }
          }
          {{/formParams}}

          {{^bodyParams}}{{^formParams}}val queryParams = request.getQueryParameters
          val result: {{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}Unit{{/returnType}} = api.{{operationId}}(
          {{#pathParams}}{{paramName}}.to{{dataType}}{{#hasMore}}, {{/hasMore}}{{/pathParams}}
          {{#hasQueryParams}}{{#hasPathParams}}, {{/hasPathParams}}{{#queryParams}}{{^required}}Option({{/required}}queryParams.get("{{paramName}}"){{^required}}).map(_{{/required}}.get(0).to{{dataType}}{{^required}}){{/required}}{{#hasMore}}/* has more query params */, {{/hasMore}}{{/queryParams}}{{/hasQueryParams}}
          )
          val r: JObservable[Void] = respond(result, response)
          r
          {{/formParams}}{{/bodyParams}}
{{/operation}}
           case _ => notFoundResponse(response)
         }
     }

     def respond[A](messageObj: A, response: HttpServerResponse[ByteBuf])(implicit codec: Codec[A]): rx.Observable[Void] = {
         val message = Serializer.serialize(messageObj)
         response.setStatus(HttpResponseStatus.OK)
         val content: ByteBuf =
             response.getAllocator
             .buffer(message.length)
             .writeBytes(message.getBytes)
         val headers = response.getHeaders
         headers.set(HttpHeaderNames.CONTENT_LENGTH, message.length)
         headers.set(HttpHeaderNames.CONTENT_TYPE, "application/json")
         response.write(content)
         response.close(true)
     }

     def badRequest(response: HttpServerResponse[ByteBuf]) = {
       response.setStatus(HttpResponseStatus.BAD_REQUEST)
       response.writeString("Bad request")
       response.close(true)
     }

     def notFoundResponse(response: HttpServerResponse[ByteBuf]) = {
       response.setStatus(HttpResponseStatus.NOT_FOUND)
       response.writeString("Service not found")
       response.close(true)
     }

}
{{/operations}}

object {{classname}}Router {
  def createService(api: {{classname}}): Service = Service(new {{classname}}Router(api))
}
